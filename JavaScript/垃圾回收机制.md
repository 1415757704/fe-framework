#### 引用计数法
根据当前对象被引用的次数，当引用的次数为0的时候，在下一次的垃圾回收的时候，该内存对象就会被回收。

+ 在相互引用的时候会造成内存泄漏
+ 对于被引用的次数不可预知，在分配内存存储记录的时候，可能会造成浪费
#### 标记清除
+ 标记阶段：把所有活动对象做上标记。<br/>
    js调用函数执行的时候都会创建一个上下文对象，上下文对象会创建对应的作用域，然后获取当前函数顶部的函数的上下文对象关联的作用域链，链接到自身的作用域上形成作用域链，标记清除即可沿作用域逐层往里遍历（对，是深度遍历），当遍历到堆中对象时，说明该对象被引用着，则打上一个标记，继续递归遍历（因为肯定存在堆中对象引用另一个堆中对象），直到遍历到最后一个（最深的一层作用域）节点，也就是当前的作用域。循环引用的对象的内部的引用并没有在当前的作用域中，所以不会被标记，即会垃圾回收。标记清除其实也是利用上下文对象和作用域链实现的。
+ 清除阶段：把没有标记（也就是非活动对象）销毁。
