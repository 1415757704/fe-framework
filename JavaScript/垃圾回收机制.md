#### 引用计数法
根据当前对象被引用的次数，当引用的次数为0的时候，在下一次的垃圾回收的时候，该内存对象就会被回收。

+ 在相互引用的时候会造成内存泄漏
+ 对于被引用的次数不可预知，在分配内存存储记录的时候，可能会造成浪费
#### 标记清除
+ 标记阶段：把所有活动对象做上标记。<br/>
    根可以理解成我们的全局作用域，GC从全局作用域的变量，沿作用域逐层往里遍历（对，是深度遍历），当遍历到堆中对象时，说明该对象被引用着，则打上一个标记，继续递归遍历（因为肯定存在堆中对象引用另一个堆中对象），直到遍历到最后一个（最深的一层作用域）节点。(根据作用域来进行垃圾回收，对于循环引用，当对象没有被外部作用域的引用对象引用的话，则会被回收。)
+ 清除阶段：把没有标记（也就是非活动对象）销毁。
