#### 作用域：变量的可见范围
代码的执行之前经历三个阶段
+ 词法分析：对代码进行拆解
+ 语法分析：根据上面的拆解结果生成抽象语法树
+ 代码生成：根据抽象语法树执行相应的代码，例如创建一个对象，为对象分配相应的内存 <br/>
 代码的执行包括编译器的编译，这个阶段会检测当前代码，当遇到变量的声明的时候，会询问当前的作用域是否存在该变量的声明，不存在则在当前作用域创建一个变量。在编译器对代码编译完成之后，会为引擎生成对应的可执行代码。引擎在执行代码的时候，会询问当前作用域是否有该变量，没有的话继续向上查找，直到在对应的作用域名中找到该变量，然后对其执行赋值操作。<br/>
所以var a = 2分为两个阶段：1）编译阶段：在作用域中声明对应的变量并且初始化为undefined。2）执行阶段：a=2，引擎在作用域中找到对应的变量执行赋值操作。
#### 变量的提升
 在编译器编译阶段，会将代码中变量、函数的声明进行提前声明，放置到对应的作用域中。let是块级作用域、var是函数作用域。
+ var在编译阶段会执行变量的创建和初始化操作，初始化为undefined
+ let在编译阶段只会执行创建，没有初始化，所以即使变量提升，在变量没有手动初始化的之前都是不能使用的，这就是所谓的暂时性死区
+ function的创建、初始化、赋值都被提升
+ const与let的区别在与const只有创建和初始化操作，没有赋值
    ```
    function fn(){
        var x = 1   // 创建、初始化为undefined，赋值为1，这里的初始化提前了，所以x=1不是初始化操作
        var y = 2
    }
    fn()
    {
        let x = 1 // 执行 x = 1，将 x 「初始化」为 1（这并不是一次赋值，因为let初始化没有被提升，如果代码是 let x，就将 x 初始化为 undefined)
        x = 2 // 赋值
    }
    ```
#### 执行上下文
js的代码的执行环境，决定了当前可以获取到的变量、函数等。js是单线程，在运行的时候只会有一个环境。当函数被调用的时候就有生成一个上下文对象，压入到执行栈中，js引擎总是在栈顶上下文中执行。创建上下文的时候会创建对应的作用域链（js是动态执行的语言，只有在执行的时候才会创建对应的作用域），最后将this赋予这一function所属的Object。<br/>
上下文指的是this，即使调用函数的对象，这也是决定能通过this这个上下文对象能获取到那些变量。而作用域是不通过this调用的变量。
#### 作用域链
js中函数中可以嵌套函数的定义，在执行函数的时候会创建上下文对象，上下文对象会绑定当前函数中的变量和函数，所以嵌套在函数中定义的函数也就绑定到当前的上下文对象中，而在创建上下文对象的时候会创建对应的作用域。<br/>
作用域链实际上就是自下而上地将所有嵌套定义的上下文所绑定的变量对象串接到一起，使嵌套的function可以“继承”上层上下文的变量。作用域链是基于上下文创建利用上下文对象绑定当前函数中的变量和函数，从而在调用内部函数的时候，可以链接上面的上下文对象创建的作用域，形成作用域链。    
#### 闭包
闭包就是利用顶层函数创建上下文对象的时候，会绑定过内部的函数，将内部函数返回并调用执行该内部函数的时候，会创建一个新的上下文对象，创建自己的作用域，还可以通过上次的绑定操作找到对应的作用域链，然后将自己的作用域与前面的上下文对象的作用域链链接起来，从而形成作用域链。<br/>
虽然当前的执行环境操作不了函数的内部变量，但是通过这个作用域链，返回的函数就可以操作不属于执行环境的作用域，从而获取到对应的变量。

http://blog.rainy.im/2015/07/04/scope-chain-and-prototype-chain-in-js/    
